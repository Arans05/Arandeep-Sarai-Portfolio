<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Improved Classic Pong</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap');
  body {
    margin: 0;
    background: #111827;
    color: #f3f4f6;
    font-family: 'Inter', sans-serif;
    display: flex;
    flex-direction: column;
    align-items: center;
    height: 100vh;
    overflow: hidden;
    user-select: none;
  }
  canvas {
    background: #000;
    border: 3px solid #4f46e5;
    border-radius: 12px;
    box-shadow: 0 0 20px #4f46e5aa;
    max-width: 95vw;
    max-height: 70vh;
    display: block;
  }
  #scoreboard {
    margin: 1rem 0;
    font-size: 1.5rem;
    font-weight: 600;
    letter-spacing: 0.05em;
  }
  #controls {
    display: flex;
    gap: 1rem;
    margin-bottom: 1rem;
  }
  button {
    background: #4f46e5;
    border: none;
    border-radius: 8px;
    padding: 0.7rem 1.5rem;
    color: white;
    font-weight: 600;
    cursor: pointer;
    box-shadow: 0 4px 6px #00000080;
    transition: background-color 0.3s ease;
  }
  button:hover {
    background: #4338ca;
  }
  #message {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: #1f2937cc;
    padding: 1rem 2rem;
    border-radius: 12px;
    font-size: 1.5rem;
    font-weight: 700;
    color: #fef3c7;
    display: none;
    pointer-events: none;
  }
  @media (max-width: 600px) {
    #scoreboard {
      font-size: 1.2rem;
    }
    button {
      padding: 0.5rem 1rem;
      font-size: 0.9rem;
    }
  }
</style>
</head>
<body>
  <div id="scoreboard">Player 1: 0 — Player 2: 0</div>
  <canvas id="game" width="900" height="600"></canvas>
  <div id="controls">
    <button id="startBtn">Start</button>
    <button id="pauseBtn" disabled>Pause</button>
    <button id="resetBtn">Reset</button>
  </div>
  <div id="message"></div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const scoreboard = document.getElementById('scoreboard');
  const message = document.getElementById('message');
  const startBtn = document.getElementById('startBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const resetBtn = document.getElementById('resetBtn');

  const PADDLE_WIDTH = 15;
  const PADDLE_HEIGHT = 120;
  const BALL_RADIUS = 10;
  const MAX_SCORE = 7;
  const PADDLE_SPEED = 500; // pixels per second
  const BALL_SPEED_START = 350;
  const BALL_SPEED_INCREMENT = 20;
  const BALL_SPEED_MAX = 700;

  // Game state variables
  let paddle1Y, paddle2Y;
  let ballX, ballY, ballSpeedX, ballSpeedY;
  let player1Score, player2Score;
  let lastTime = 0;
  let isRunning = false;
  let isPaused = false;
  let animationFrameId;

  // Input states
  const input = {
    w: false,
    s: false,
    ArrowUp: false,
    ArrowDown: false
  };

  // Sound effects (simple beep)
  const beep = (frequency, duration) => {
    try {
      const context = new AudioContext();
      const oscillator = context.createOscillator();
      oscillator.frequency.value = frequency;
      oscillator.type = 'square';
      oscillator.connect(context.destination);
      oscillator.start();
      oscillator.stop(context.currentTime + duration / 1000);
    } catch {
      // AudioContext might be unsupported on some browsers
    }
  };

  function resetPositions() {
    paddle1Y = (canvas.height - PADDLE_HEIGHT) / 2;
    paddle2Y = (canvas.height - PADDLE_HEIGHT) / 2;

    ballX = canvas.width / 2;
    ballY = canvas.height / 2;
    const angle = (Math.random() * Math.PI / 4) - Math.PI / 8; // random angle between -22.5 to +22.5 degrees
    const direction = Math.random() > 0.5 ? 1 : -1;
    ballSpeedX = direction * BALL_SPEED_START * Math.cos(angle);
    ballSpeedY = BALL_SPEED_START * Math.sin(angle);
  }

  function resetGame() {
    player1Score = 0;
    player2Score = 0;
    resetPositions();
    updateScoreboard();
    showMessage('Press Start to Play');
    isRunning = false;
    isPaused = false;
    pauseBtn.disabled = true;
    startBtn.disabled = false;
  }

  function updateScoreboard() {
    scoreboard.textContent = `Player 1: ${player1Score} — Player 2: ${player2Score}`;
  }

  function showMessage(text, timeout = 3000) {
    message.textContent = text;
    message.style.display = 'block';
    if (timeout) {
      setTimeout(() => {
        message.style.display = 'none';
      }, timeout);
    }
  }

  function hideMessage() {
    message.style.display = 'none';
  }

  function drawNet() {
    const segmentHeight = 20;
    ctx.strokeStyle = '#6b7280'; // gray-500
    ctx.lineWidth = 3;
    for (let y = 0; y < canvas.height; y += segmentHeight * 2) {
      ctx.beginPath();
      ctx.moveTo(canvas.width / 2, y);
      ctx.lineTo(canvas.width / 2, y + segmentHeight);
      ctx.stroke();
    }
  }

  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Background glow
    ctx.shadowColor = '#4f46e5';
    ctx.shadowBlur = 15;

    // Left paddle
    ctx.fillStyle = '#4f46e5';
    ctx.fillRect(20, paddle1Y, PADDLE_WIDTH, PADDLE_HEIGHT);

    // Right paddle
    ctx.fillRect(canvas.width - 20 - PADDLE_WIDTH, paddle2Y, PADDLE_WIDTH, PADDLE_HEIGHT);

    // Ball with glow
    ctx.beginPath();
    ctx.shadowColor = '#fbbf24'; // yellow-400 glow
    ctx.shadowBlur = 20;
    ctx.fillStyle = '#fbbf24';
    ctx.arc(ballX, ballY, BALL_RADIUS, 0, Math.PI * 2);
    ctx.fill();

    ctx.shadowBlur = 0; // reset shadow

    drawNet();
  }

  function clamp(val, min, max) {
    return Math.min(Math.max(val, min), max);
  }

  function update(dt) {
    if (!isRunning || isPaused) return;

    // Move paddles based on input and delta time
    if (input.w) paddle1Y -= PADDLE_SPEED * dt;
    if (input.s) paddle1Y += PADDLE_SPEED * dt;
    if (input.ArrowUp) paddle2Y -= PADDLE_SPEED * dt;
    if (input.ArrowDown) paddle2Y += PADDLE_SPEED * dt;

    // Clamp paddles within screen
    paddle1Y = clamp(paddle1Y, 0, canvas.height - PADDLE_HEIGHT);
    paddle2Y = clamp(paddle2Y, 0, canvas.height - PADDLE_HEIGHT);

    // Move ball
    ballX += ballSpeedX * dt;
    ballY += ballSpeedY * dt;

    // Bounce off top/bottom walls
    if (ballY - BALL_RADIUS < 0) {
      ballY = BALL_RADIUS;
      ballSpeedY *= -1;
      beep(500, 50);
    }
    if (ballY + BALL_RADIUS > canvas.height) {
      ballY = canvas.height - BALL_RADIUS;
      ballSpeedY *= -1;
      beep(500, 50);
    }

    // Paddle collision check helper
    function paddleCollision(paddleX, paddleY) {
      return (
        ballX - BALL_RADIUS < paddleX + PADDLE_WIDTH &&
        ballX + BALL_RADIUS > paddleX &&
        ballY + BALL_RADIUS > paddleY &&
        ballY - BALL_RADIUS < paddleY + PADDLE_HEIGHT
      );
    }

    // Left paddle collision
    if (ballSpeedX < 0 && paddleCollision(20, paddle1Y)) {
      ballX = 20 + PADDLE_WIDTH + BALL_RADIUS;
      reflectBall(paddle1Y);
      beep(700, 80);
    }
    // Right paddle collision
    else if (ballSpeedX > 0 && paddleCollision(canvas.width - 20 - PADDLE_WIDTH, paddle2Y)) {
      ballX = canvas.width - 20 - PADDLE_WIDTH - BALL_RADIUS;
      reflectBall(paddle2Y);
      beep(700, 80);
    }

    // Check if ball goes out left or right (score)
    if (ballX - BALL_RADIUS < 0) {
      player2Score++;
      updateScoreboard();
      beep(300, 200);
      if (player2Score >= MAX_SCORE) return endGame('Player 2 Wins!');
      resetPositions();
      pauseGameBriefly();
    } else if (ballX + BALL_RADIUS > canvas.width) {
      player1Score++;
      updateScoreboard();
      beep(300, 200);
      if (player1Score >= MAX_SCORE) return endGame('Player 1 Wins!');
      resetPositions();
      pauseGameBriefly();
    }
  }

  // Reflect the ball after paddle hit with angle depending on where ball hit the paddle
  function reflectBall(paddleY) {
    const paddleCenter = paddleY + PADDLE_HEIGHT / 2;
    const relativeIntersectY = ballY - paddleCenter;
    const normalizedRelativeY = relativeIntersectY / (PADDLE_HEIGHT / 2);
    const bounceAngle = normalizedRelativeY * (Math.PI / 4); // max 45 degrees angle

    const speed = Math.min(Math.sqrt(ballSpeedX * ballSpeedX + ballSpeedY * ballSpeedY) + BALL_SPEED_INCREMENT, BALL_SPEED_MAX);

    ballSpeedX = (ballSpeedX > 0 ? -1 : 1) * speed * Math.cos(bounceAngle);
    ballSpeedY = speed * Math.sin(bounceAngle);
  }

  function gameLoop(timestamp = 0) {
    if (!lastTime) lastTime = timestamp;
    const dt = (timestamp - lastTime) / 1000; // delta time in seconds
    lastTime = timestamp;

    update(dt);
    draw();

    if (isRunning && !isPaused) {
      animationFrameId = requestAnimationFrame(gameLoop);
    }
  }

  // Start game
  function startGame() {
    if (isRunning) return;
    isRunning = true;
    isPaused = false;
    lastTime = 0;
    hideMessage();
    pauseBtn.disabled = false;
    startBtn.disabled = true;
    animationFrameId = requestAnimationFrame(gameLoop);
  }

  // Pause game
  function pauseGame() {
    if (!isRunning) return;
    isPaused = true;
    pauseBtn.disabled = true;
    startBtn.disabled = false;
    showMessage('Game Paused. Press Start to Resume.', 0);
    cancelAnimationFrame(animationFrameId);
  }

  // Pause briefly after scoring so players can prepare
  function pauseGameBriefly() {
    isPaused = true;

    // Clear input so paddles don't stay stuck
    input.w = false;
    input.s = false;
    input.ArrowUp = false;
    input.ArrowDown = false;

    showMessage('Point scored! Get ready...', 2000);

    cancelAnimationFrame(animationFrameId);

    setTimeout(() => {
      if (isRunning) {
        isPaused = false;
        hideMessage();
        lastTime = performance.now(); // proper timestamp to avoid big dt
        animationFrameId = requestAnimationFrame(gameLoop);
      }
    }, 2000);
  }

  // End game
  function endGame(text) {
    isRunning = false;
    pauseBtn.disabled = true;
    startBtn.disabled = false;
    showMessage(text + ' Press Reset to play again.', 0);
    cancelAnimationFrame(animationFrameId);
  }

  // Reset game
  function resetGameHandler() {
    cancelAnimationFrame(animationFrameId);
    resetGame();
  }

  // Keyboard listeners
  window.addEventListener('keydown', e => {
    if (['w', 's', 'ArrowUp', 'ArrowDown'].includes(e.key)) {
      input[e.key] = true;
      e.preventDefault();
    }
  });
  window.addEventListener('keyup', e => {
    if (['w', 's', 'ArrowUp', 'ArrowDown'].includes(e.key)) {
      input[e.key] = false;
      e.preventDefault();
    }
  });

  // Initialize
  resetGame();

  startBtn.addEventListener('click', () => {
    if (!isRunning) startGame();
    else if (isPaused) {
      isPaused = false;
      hideMessage();
      pauseBtn.disabled = false;
      startBtn.disabled = true;
      lastTime = performance.now(); // reset time on resume
      animationFrameId = requestAnimationFrame(gameLoop);
    }
  });

  pauseBtn.addEventListener('click', () => {
    if (!isPaused) pauseGame();
  });

  resetBtn.addEventListener('click', resetGameHandler);

})();
</script>
</body>
</html>

